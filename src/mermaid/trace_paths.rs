use super::{
    counted_prefix::CountedPrefix,
    service_oper_graph::{Position, ServiceOperGraph, ServiceOperationType},
    trace_data::TraceData,
    tt_utils::{get_call_chain_prefix, mark_selected_call_chain, split_service},
    MermaidScope,
};
use crate::{
    stats::{CChainStatsKey, LeafServiceOper},
    EdgeValue,
};
use regex::{self, Regex};
use std::collections::HashMap;

/// The trace-tree is used to build the Mermaid-charts.
/// This datastructure is derived from either:
///    * a Stiched dataset (as generated by stitch)
///    * A StatsRec (as generated by trace_analysis snapshot)
/// This trace-tree will only contain the call-chains and does not extract the process-oper statistics, as that data is not needed (would be a duplicate).
///
/// NOTE: this structure contains a collection of paths, but is not yet a TraceTree as it does not merge joined prefixes of paths to a single prefix (real tree structure)   
pub struct TracePaths(pub HashMap<LeafServiceOper, Vec<TraceData>>);


impl TracePaths {

    /// Build the ServiceOperationGraph based on the TraceTree (Stiched or StatsRec data) and for the selected 'service_oper'.
    /// The input 'data' is a dataset of stitched data-point containings all traces though the graph and the statistics for the endpoint of this trace.
    /// In this function we reconstruct the original graph by taking the last step of each of the traces that pass through or end in 'service_oper'.
    /// The statistic collected is the average number of traces that pass through a node.
    /// Some nodes are reachable via multiple paths, in that case the sum is used to aggegate the counts.
    ///
    /// This is a two stage-process.
    /// 1. find all paths in 'data' that touch 'service_oper' and construct the graph including the edge_value statistics (often counts). In this stage we also collect that paths leading to 'service_oper'
    /// 2. The (deduplicated) set of all paths leading into 'service_oper' are used to construct all the upstream process-steps. However, we do not have edge_value-statistics for these paths
    fn build_serv_oper_graph(&self, service_oper: &str) -> ServiceOperGraph {
        let esc_service_oper = regex::escape(service_oper);
        let re_service_oper =
            Regex::new(&esc_service_oper).expect("Failed to create regex for service_oper");
        let re_so_prefix = Regex::new(&format!("^.*{}", esc_service_oper))
            .expect("Failed to create regex for service_oper_prefix");
        let service = split_service(service_oper);

        // Stage-1: build the downstream graphs and collect the set of incoming paths via the counted_prefix
        let (sog, counted_prefix) = self.0
            .iter()
            .flat_map(|(_k, ccd_vec)| {
                // _k is final service/operation of the call-chain, which is not needed here
                ccd_vec
                    .iter()
                    .filter(|ccd| re_service_oper.find(&ccd.full_key).is_some())
                    .filter_map(|ccd| {
                        // This closure only takes the last two steps of the path, as this transition is covered by the corresponding dataset
                        let cc = CChainStatsKey::parse(&ccd.full_key).unwrap();
                        if cc.call_chain.len() >= 2 {
                            let skip = cc.call_chain.len() - 2;
                            let mut cc = cc.call_chain.into_iter().skip(skip);
                            let from = cc.next().unwrap();
                            let to = cc.next().unwrap();

                            let prefix = re_so_prefix.find(&ccd.full_key).expect("Prefix not found");

                            // and result as tuple for to be folded
                            Some((prefix, from, to, &ccd.data))
                        } else {
                            println!(
                                "Skipping call-chain as it is consists of a single step '{}' (no link)",
                                ccd.full_key
                            );
                            None
                        }
                    })
            })
            .fold(
                (ServiceOperGraph::new(), CountedPrefix::new()),
                |mut sog_cp, (prefix, from, to, edge_data)| {
                    // add the connection to the graph
                    sog_cp
                        .0
                        .add_connection(from, to, edge_data, service, Position::Outbound);
                    // add the counted prefix
                    sog_cp.1.add(prefix.as_str(), edge_data.count);
                    sog_cp
                },
            );

        println!("TODO: skipped stage 2 in TraceTree.build_serv_oper_graph. FIX IT!!");
        // // Stage 2: amend the graph with the upstream paths (inbound paths)
        // counted_prefix.0.into_iter().for_each(|(k, v)| {
        //     let cc = CChainStatsKey::parse(&format!("{k} [Unknown] & &")).unwrap();
        //     std::iter::zip(cc.call_chain.iter(), cc.call_chain.iter().skip(1)).for_each(
        //         |(s1, s2)| {
        //             sog.add_connection(s1.clone(), s2.clone(), None, service, Position::Inbound)
        //         },
        //     );
        // });

        sog
    }

    /// Mark downstream nodes as reachable and do a count of the number of paths reachable over current path up to 'service_oper' that is under investigation
    fn mark_and_count_downstream(
        &self,
        mut sog: ServiceOperGraph,
        service_oper: &str,
        call_chain_key: &str,
    ) -> ServiceOperGraph {
        let prefix = get_call_chain_prefix(service_oper, call_chain_key);

        self.0.iter().for_each(|(_k, ccd_vec)| {
            // _k is final service/operation of the call-chain and this is not relevant
            ccd_vec
                .iter()
                .filter(|ccd| ccd.full_key.starts_with(&prefix))
                .for_each(|ccd| {
                    let cc = CChainStatsKey::parse(&ccd.full_key).unwrap();
                    if cc.call_chain.len() >= 2 {
                        let skip = cc.call_chain.len() - 2;
                        let mut cc = cc.call_chain.into_iter().skip(skip);
                        let from = cc.next().unwrap();
                        let to = cc.next().unwrap();

                        // and update the reach_count
                        sog.update_inbound_path_count(&from, &to, &ccd.data);
                    } else {
                        println!(
                            "Skipping call-chain as it is consists of a single step '{}' (no link)",
                            ccd.full_key
                        );
                    }
                });
        });
        //TODO: to implement
        sog
    }

    /// Build a diagram for the 'service_oper'  and 'call_chain_key' based on the stitched 'data'.
    pub fn get_diagram(
        &self,
        service_oper: &str,
        call_chain_key: Option<&str>,
        edge_value: EdgeValue,
        scope: MermaidScope,
        compact: bool,
    ) -> String {
        let sog = self.build_serv_oper_graph(service_oper);

        let mut sog = if let Some(call_chain_key) = call_chain_key {
            let sog = self.mark_and_count_downstream(sog, service_oper, call_chain_key);

            // Emphasize the selected path if the call_chain-key is provided
            mark_selected_call_chain(sog, call_chain_key)
        } else {
            sog
        };

        sog.update_service_operation_type(service_oper, ServiceOperationType::Emphasized);
        sog.mermaid_diagram(scope, compact, edge_value)
    }
}
